/**
 * CLI analytics integration for the unified monitoring system
 */

import { monitoring } from '../system';\nimport { v4 as uuidv4 } from 'uuid';\nimport os from 'os';\nimport crypto from 'crypto';\n\n/**\n * Unified CLI analytics that replaces the separate analytics in CLI and create-app packages\n */\nexport class CLIAnalyticsIntegration {\n  private machineId: string;\n  \n  constructor() {\n    this.machineId = this.generateMachineId();\n  }\n  \n  /**\n   * Check if telemetry is disabled\n   */\n  private isTelemetryDisabled(): boolean {\n    return (\n      process.env.VOLTAGENT_TELEMETRY_DISABLED === '1' ||\n      process.env.VOLTAGENT_TELEMETRY_DISABLED === 'true'\n    );\n  }\n  \n  /**\n   * Generate a machine-specific but anonymous ID\n   */\n  private generateMachineId(): string {\n    try {\n      const hostname = os.hostname();\n      const cpus = os.cpus().length;\n      const platform = os.platform();\n      const arch = os.arch();\n      \n      const dataToHash = `${hostname}-${cpus}-${platform}-${arch}`;\n      return crypto.createHash('sha256').update(dataToHash).digest('hex').substring(0, 32);\n    } catch (error) {\n      return uuidv4();\n    }\n  }\n  \n  /**\n   * Get OS info for analytics\n   */\n  private getOSInfo() {\n    try {\n      return {\n        os_platform: os.platform(),\n        os_release: os.release(),\n        os_version: os.version(),\n        os_arch: os.arch(),\n        node_version: process.version,\n      };\n    } catch (error) {\n      return {\n        os_platform: 'unknown',\n        os_release: 'unknown',\n        os_version: 'unknown',\n        os_arch: 'unknown',\n        node_version: 'unknown',\n      };\n    }\n  }\n  \n  /**\n   * Capture CLI initialization events\n   */\n  async captureInitEvent(options: {\n    packageManager: string;\n    projectName?: string;\n    template?: string;\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'cli_init',\n      agentId: 'cli',\n      properties: {\n        package_manager: options.packageManager,\n        project_name: options.projectName,\n        template: options.template,\n        machine_id: this.machineId,\n        ...this.getOSInfo(),\n      },\n    });\n  }\n  \n  /**\n   * Capture project creation events\n   */\n  async captureProjectCreation(options: {\n    projectName: string;\n    packageManager?: string;\n    typescript: boolean;\n    fromExample?: string;\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'project_created',\n      agentId: 'cli',\n      properties: {\n        project_name: options.projectName,\n        package_manager: options.packageManager || 'unknown',\n        typescript: options.typescript,\n        from_example: options.fromExample || null,\n        machine_id: this.machineId,\n        ...this.getOSInfo(),\n      },\n    });\n  }\n  \n  /**\n   * Capture CLI update check events\n   */\n  async captureUpdateEvent(options: {\n    hadUpdates: boolean;\n    currentVersion?: string;\n    latestVersion?: string;\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'cli_update_check',\n      agentId: 'cli',\n      properties: {\n        had_updates: options.hadUpdates,\n        current_version: options.currentVersion,\n        latest_version: options.latestVersion,\n        machine_id: this.machineId,\n        ...this.getOSInfo(),\n      },\n    });\n  }\n  \n  /**\n   * Capture whoami command events\n   */\n  async captureWhoamiEvent(options: {\n    numVoltPackages: number;\n    packages?: string[];\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'cli_whoami',\n      agentId: 'cli',\n      properties: {\n        num_volt_packages: options.numVoltPackages,\n        packages: options.packages,\n        machine_id: this.machineId,\n        ...this.getOSInfo(),\n      },\n    });\n  }\n  \n  /**\n   * Capture CLI command usage\n   */\n  async captureCommandUsage(options: {\n    command: string;\n    subcommand?: string;\n    flags?: string[];\n    duration?: number;\n    success: boolean;\n    error?: string;\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'cli_command_usage',\n      agentId: 'cli',\n      properties: {\n        command: options.command,\n        subcommand: options.subcommand,\n        flags: options.flags,\n        duration: options.duration,\n        success: options.success,\n        error_message: options.error,\n        machine_id: this.machineId,\n        ...this.getOSInfo(),\n      },\n    });\n    \n    // Record command metrics\n    await monitoring.recordMetric({\n      name: 'cli.command.usage',\n      value: 1,\n      timestamp: new Date().toISOString(),\n      tags: {\n        command: options.command,\n        subcommand: options.subcommand || 'none',\n        success: options.success.toString(),\n      },\n    });\n    \n    if (options.duration) {\n      await monitoring.recordMetric({\n        name: 'cli.command.duration',\n        value: options.duration,\n        timestamp: new Date().toISOString(),\n        tags: {\n          command: options.command,\n          subcommand: options.subcommand || 'none',\n        },\n        unit: 'milliseconds',\n      });\n    }\n  }\n  \n  /**\n   * Capture error events\n   */\n  async captureError(options: {\n    command: string;\n    errorMessage: string;\n    stackTrace?: string;\n    context?: Record<string, any>;\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'cli_error',\n      agentId: 'cli',\n      properties: {\n        command: options.command,\n        error_message: options.errorMessage,\n        stack_trace: options.stackTrace,\n        context: options.context,\n        machine_id: this.machineId,\n        ...this.getOSInfo(),\n      },\n    });\n    \n    // Record error metrics\n    await monitoring.recordMetric({\n      name: 'cli.error.count',\n      value: 1,\n      timestamp: new Date().toISOString(),\n      tags: {\n        command: options.command,\n        error_type: this.categorizeError(options.errorMessage),\n      },\n    });\n  }\n  \n  /**\n   * Capture performance metrics\n   */\n  async capturePerformanceMetrics(options: {\n    command: string;\n    memoryUsage?: NodeJS.MemoryUsage;\n    cpuUsage?: NodeJS.CpuUsage;\n    duration: number;\n  }): Promise<void> {\n    if (this.isTelemetryDisabled()) return;\n    \n    // Record performance metrics\n    if (options.memoryUsage) {\n      await monitoring.recordMetric({\n        name: 'cli.memory.heap_used',\n        value: options.memoryUsage.heapUsed,\n        timestamp: new Date().toISOString(),\n        tags: {\n          command: options.command,\n        },\n        unit: 'bytes',\n      });\n      \n      await monitoring.recordMetric({\n        name: 'cli.memory.heap_total',\n        value: options.memoryUsage.heapTotal,\n        timestamp: new Date().toISOString(),\n        tags: {\n          command: options.command,\n        },\n        unit: 'bytes',\n      });\n    }\n    \n    if (options.cpuUsage) {\n      await monitoring.recordMetric({\n        name: 'cli.cpu.user',\n        value: options.cpuUsage.user,\n        timestamp: new Date().toISOString(),\n        tags: {\n          command: options.command,\n        },\n        unit: 'microseconds',\n      });\n      \n      await monitoring.recordMetric({\n        name: 'cli.cpu.system',\n        value: options.cpuUsage.system,\n        timestamp: new Date().toISOString(),\n        tags: {\n          command: options.command,\n        },\n        unit: 'microseconds',\n      });\n    }\n    \n    await monitoring.recordMetric({\n      name: 'cli.command.duration',\n      value: options.duration,\n      timestamp: new Date().toISOString(),\n      tags: {\n        command: options.command,\n      },\n      unit: 'milliseconds',\n    });\n  }\n  \n  /**\n   * Categorize error for better analytics\n   */\n  private categorizeError(errorMessage: string): string {\n    const message = errorMessage.toLowerCase();\n    \n    if (message.includes('network') || message.includes('fetch') || message.includes('connection')) {\n      return 'network';\n    }\n    if (message.includes('permission') || message.includes('access')) {\n      return 'permission';\n    }\n    if (message.includes('not found') || message.includes('enoent')) {\n      return 'not_found';\n    }\n    if (message.includes('syntax') || message.includes('parse')) {\n      return 'syntax';\n    }\n    if (message.includes('timeout')) {\n      return 'timeout';\n    }\n    \n    return 'unknown';\n  }\n}\n\n// Export a default instance\nexport const cliAnalytics = new CLIAnalyticsIntegration();

