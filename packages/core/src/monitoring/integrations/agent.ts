/**
 * Agent integration for the unified monitoring system
 */

import { monitoring } from '../system';
import { v4 as uuidv4 } from 'uuid';
import type { AgentStatus } from '../../agent/types';
import type { UsageInfo } from '../../agent/providers/base/types';

/**
 * Monitoring integration for VoltAgent agents
 */
export class AgentMonitoringIntegration {
  private agentId: string;
  private activeOperations: Map<string, { startTime: number; type: string }> = new Map();
  
  constructor(agentId: string) {
    this.agentId = agentId;
  }
  
  /**
   * Track agent lifecycle events
   */
  async trackAgentLifecycle(event: 'created' | 'started' | 'stopped' | 'destroyed', metadata?: Record<string, any>): Promise<void> {\n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'agent_lifecycle',\n      agentId: this.agentId,\n      properties: {\n        lifecycle_event: event,\n        ...metadata,\n      },\n    });\n    \n    // Record lifecycle metrics\n    await monitoring.recordMetric({\n      name: 'agent.lifecycle.event',\n      value: 1,\n      timestamp: new Date().toISOString(),\n      tags: {\n        agent_id: this.agentId,\n        event_type: event,\n      },\n    });\n  }\n  \n  /**\n   * Track agent status changes\n   */\n  async trackStatusChange(oldStatus: AgentStatus, newStatus: AgentStatus, metadata?: Record<string, any>): Promise<void> {\n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'agent_status_change',\n      agentId: this.agentId,\n      properties: {\n        old_status: oldStatus,\n        new_status: newStatus,\n        ...metadata,\n      },\n    });\n    \n    // Record status metrics\n    await monitoring.recordMetric({\n      name: 'agent.status.change',\n      value: 1,\n      timestamp: new Date().toISOString(),\n      tags: {\n        agent_id: this.agentId,\n        old_status: oldStatus,\n        new_status: newStatus,\n      },\n    });\n  }\n  \n  /**\n   * Start tracking an operation\n   */\n  startOperation(operationType: string, metadata?: Record<string, any>): string {\n    const operationId = uuidv4();\n    \n    this.activeOperations.set(operationId, {\n      startTime: Date.now(),\n      type: operationType,\n    });\n    \n    // Track operation start asynchronously\n    monitoring.trackEvent({\n      id: `${operationId}-start`,\n      timestamp: new Date().toISOString(),\n      type: 'agent_operation_start',\n      agentId: this.agentId,\n      properties: {\n        operation_id: operationId,\n        operation_type: operationType,\n        ...metadata,\n      },\n    }).catch(error => {\n      console.error('[AgentMonitoring] Failed to track operation start:', error);\n    });\n    \n    return operationId;\n  }\n  \n  /**\n   * End tracking an operation\n   */\n  async endOperation(\n    operationId: string, \n    result: { success: boolean; error?: any; usage?: UsageInfo }, \n    metadata?: Record<string, any>\n  ): Promise<void> {\n    const operation = this.activeOperations.get(operationId);\n    if (!operation) {\n      console.warn(`[AgentMonitoring] Operation ${operationId} not found`);\n      return;\n    }\n    \n    this.activeOperations.delete(operationId);\n    \n    const duration = Date.now() - operation.startTime;\n    const status = result.success ? 'success' : 'error';\n    \n    // Track operation completion\n    await monitoring.trackEvent({\n      id: `${operationId}-end`,\n      timestamp: new Date().toISOString(),\n      type: 'agent_operation_end',\n      agentId: this.agentId,\n      properties: {\n        operation_id: operationId,\n        operation_type: operation.type,\n        duration,\n        status,\n        error_message: result.error instanceof Error ? result.error.message : String(result.error || ''),\n        usage: result.usage,\n        ...metadata,\n      },\n    });\n    \n    // Record operation metrics\n    await monitoring.recordMetric({\n      name: 'agent.operation.duration',\n      value: duration,\n      timestamp: new Date().toISOString(),\n      tags: {\n        agent_id: this.agentId,\n        operation_type: operation.type,\n        status,\n      },\n      unit: 'milliseconds',\n    });\n    \n    // Record usage metrics if available\n    if (result.usage) {\n      if (result.usage.promptTokens) {\n        await monitoring.recordMetric({\n          name: 'agent.tokens.prompt',\n          value: result.usage.promptTokens,\n          timestamp: new Date().toISOString(),\n          tags: {\n            agent_id: this.agentId,\n            operation_type: operation.type,\n          },\n        });\n      }\n      \n      if (result.usage.completionTokens) {\n        await monitoring.recordMetric({\n          name: 'agent.tokens.completion',\n          value: result.usage.completionTokens,\n          timestamp: new Date().toISOString(),\n          tags: {\n            agent_id: this.agentId,\n            operation_type: operation.type,\n          },\n        });\n      }\n      \n      if (result.usage.totalTokens) {\n        await monitoring.recordMetric({\n          name: 'agent.tokens.total',\n          value: result.usage.totalTokens,\n          timestamp: new Date().toISOString(),\n          tags: {\n            agent_id: this.agentId,\n            operation_type: operation.type,\n          },\n        });\n      }\n    }\n    \n    // Record error metrics if operation failed\n    if (!result.success) {\n      await monitoring.recordMetric({\n        name: 'agent.error.count',\n        value: 1,\n        timestamp: new Date().toISOString(),\n        tags: {\n          agent_id: this.agentId,\n          operation_type: operation.type,\n          error_type: result.error instanceof Error ? result.error.constructor.name : 'Unknown',\n        },\n      });\n    }\n  }\n  \n  /**\n   * Track tool usage\n   */\n  async trackToolUsage(\n    toolName: string, \n    toolCallId: string, \n    result: { success: boolean; duration: number; error?: any },\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    const status = result.success ? 'success' : 'error';\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'tool_usage',\n      agentId: this.agentId,\n      properties: {\n        tool_name: toolName,\n        tool_call_id: toolCallId,\n        duration: result.duration,\n        status,\n        error_message: result.error instanceof Error ? result.error.message : String(result.error || ''),\n        ...metadata,\n      },\n    });\n    \n    // Record tool metrics\n    await monitoring.recordMetric({\n      name: 'agent.tool.duration',\n      value: result.duration,\n      timestamp: new Date().toISOString(),\n      tags: {\n        agent_id: this.agentId,\n        tool_name: toolName,\n        status,\n      },\n      unit: 'milliseconds',\n    });\n    \n    await monitoring.recordMetric({\n      name: 'agent.tool.usage',\n      value: 1,\n      timestamp: new Date().toISOString(),\n      tags: {\n        agent_id: this.agentId,\n        tool_name: toolName,\n        status,\n      },\n    });\n  }\n  \n  /**\n   * Track memory operations\n   */\n  async trackMemoryOperation(\n    operationType: 'read' | 'write' | 'search' | 'delete',\n    result: { success: boolean; duration: number; itemCount?: number; error?: any },\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    const status = result.success ? 'success' : 'error';\n    \n    await monitoring.trackEvent({\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      type: 'memory_operation',\n      agentId: this.agentId,\n      properties: {\n        operation_type: operationType,\n        duration: result.duration,\n        item_count: result.itemCount,\n        status,\n        error_message: result.error instanceof Error ? result.error.message : String(result.error || ''),\n        ...metadata,\n      },\n    });\n    \n    // Record memory metrics\n    await monitoring.recordMetric({\n      name: 'agent.memory.operation.duration',\n      value: result.duration,\n      timestamp: new Date().toISOString(),\n      tags: {\n        agent_id: this.agentId,\n        operation_type: operationType,\n        status,\n      },\n      unit: 'milliseconds',\n    });\n    \n    if (result.itemCount !== undefined) {\n      await monitoring.recordMetric({\n        name: 'agent.memory.items',\n        value: result.itemCount,\n        timestamp: new Date().toISOString(),\n        tags: {\n          agent_id: this.agentId,\n          operation_type: operationType,\n        },\n      });\n    }\n  }\n  \n  /**\n   * Get active operations count\n   */\n  getActiveOperationsCount(): number {\n    return this.activeOperations.size;\n  }\n  \n  /**\n   * Get active operations\n   */\n  getActiveOperations(): Array<{ id: string; type: string; duration: number }> {\n    const now = Date.now();\n    return Array.from(this.activeOperations.entries()).map(([id, op]) => ({\n      id,\n      type: op.type,\n      duration: now - op.startTime,\n    }));\n  }\n}

